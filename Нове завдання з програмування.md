отже з програмування я все здала і вгадай що Мені дали ще одне завдання
отже його суть це голосовий помічник який відкриває програми і я хочу туди додати гпт але спочатку це має бути, ще я хочу створити текстовий редактор якому можна "надиктовувати"
- [ ] text to speach
- [ ] open apps
- [ ] speach to text
в мене краща ідея я напишу програму для синку між нутом флешкою і телефоном, не онлай там типу треба буде підключатись до ноута. Я знаю що в цьому мені допоможе стандартна бібліотека file system і оскільки в мене нема інтернету замість того щоб почекати інтернету і тоді гуглити я полізла в файли стандартних бібліотек с++ і там знайшла цікаву інформацію. Але перед тим я натрапила на бінарний код дзвоню тату 
-- Загугли мені будь ласка як перетворити двійковий код в асемблер
Тато трохи випав в осад, дитина ніби розумна а якусь маячню говорить
-- Може бінарний?
окей проїхали це, я знайшла тоді "нормальний" код на с++ і там я знайшла декілька цікавих шматочків коду
```c++

    // query

    _GLIBCXX_NODISCARD bool empty() const noexcept { return _M_pathname.empty(); }
    bool has_root_name() const;
    bool has_root_directory() const;
    bool has_root_path() const;
    bool has_relative_path() const;
    bool has_parent_path() const;
    bool has_filename() const;
    bool has_stem() const;
    bool has_extension() const;
    bool is_absolute() const;
    bool is_relative() const { return !is_absolute(); }

    // iterators
    class iterator;
    typedef iterator const_iterator;

    iterator begin() const noexcept;
    iterator end() const noexcept;
```
в цьому блоці коду показано як можна спробувати пройти по всіх файлах в папці(це не точно, я так думаю, припускаю)
```c++
// compare

    int compare(const path& __p) const noexcept;
    int compare(const string_type& __s) const;
    int compare(const value_type* __s) const;
#if __cplusplus >= 201402L
    int compare(const basic_string_view<value_type> __s) const;
#endif
```
в цьому блоці коду показано як можна порівняти, файли?(знову ж таки я припускаю)
```c++
/// An iterator for the components of a path
  class path::iterator
  {
  public:
    using difference_type	= std::ptrdiff_t;
    using value_type		= path;
    using reference		= const path&;
    using pointer		= const path*;
    using iterator_category	= std::bidirectional_iterator_tag;

    iterator() noexcept : _M_path(nullptr), _M_cur(), _M_at_end() { }

    iterator(const iterator&) = default;
    iterator& operator=(const iterator&) = default;

    reference operator*() const noexcept;
    pointer   operator->() const noexcept { return std::__addressof(**this); }

    iterator& operator++() noexcept;

    iterator  operator++(int) noexcept
    { auto __tmp = *this; ++*this; return __tmp; }

    iterator& operator--() noexcept;

    iterator  operator--(int) noexcept
    { auto __tmp = *this; --*this; return __tmp; }

    friend bool
    operator==(const iterator& __lhs, const iterator& __rhs) noexcept
    { return __lhs._M_equals(__rhs); }

    friend bool
    operator!=(const iterator& __lhs, const iterator& __rhs) noexcept
    { return !__lhs._M_equals(__rhs); }
```
це теж ітератор для того щоб пройтись по всіх файлах в директорії(знову ж таки я просто припускаю) в цій нотатці я з коду стардатної бібліотеки намагаюсь зібрати все що може стати в нагоді
```c++
// observers
    file_type  type() const noexcept { return _M_type; }
    perms      permissions() const noexcept { return _M_perms; }

```

```c++
// observers
    const filesystem::path&  path() const noexcept { return _M_path; }
    operator const filesystem::path&() const noexcept { return _M_path; }
```

```c++
explicit
    recursive_directory_iterator(const path& __p)
    : recursive_directory_iterator(__p, directory_options::none, nullptr) { }

    recursive_directory_iterator(const path& __p, directory_options __options)
    : recursive_directory_iterator(__p, __options, nullptr) { }

    recursive_directory_iterator(const path& __p,
                                 directory_options __options,
                                 error_code& __ec) noexcept
    : recursive_directory_iterator(__p, __options, &__ec) { }

    recursive_directory_iterator(const path& __p, error_code& __ec) noexcept
    : recursive_directory_iterator(__p, directory_options::none, &__ec) { }

    recursive_directory_iterator(
        const recursive_directory_iterator&) = default;

    recursive_directory_iterator(recursive_directory_iterator&&) = default;

    ~recursive_directory_iterator();

    // observers
    directory_options  options() const { return _M_options; }
    int                depth() const;
    bool               recursion_pending() const { return _M_pending; }

    const directory_entry& operator*() const;
    const directory_entry* operator->() const { return &**this; }
```

```c++
inline void
  copy(const path& __from, const path& __to)
  { copy(__from, __to, copy_options::none); }

  inline void
  copy(const path& __from, const path& __to, error_code& __ec) noexcept
  { copy(__from, __to, copy_options::none, __ec); }

  void copy(const path& __from, const path& __to, copy_options __options);

  void copy(const path& __from, const path& __to, copy_options __options,
	    error_code& __ec) noexcept;
```

це перетворилось на зборище коду в першу чергу треба щоб воно якось розпізнавало коли приєднується телефон або флешку я думаю я напишу дві програми одна для телефону інша для флешки спочатку коли я приєдную телефон хочу потім запускати утилітку яка проводить синк це по суті буде цикл який пройдеться по кожному файлу і порівняє їх спочатку напишу утилітку для телефона бо флешки не маю на руках
я хочу спочатку його проітерувати
